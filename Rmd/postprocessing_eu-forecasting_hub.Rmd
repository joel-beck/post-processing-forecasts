---
title: "EU Forecasting Hub Exploration"
author: "Joel Beck"
output:
  bookdown::html_document2:
    theme: flatly
    highlight: pygments  # kate
    toc: TRUE
    toc_float: TRUE
    toc_depth: 2
    number_sections: FALSE
    df_print: tibble
  bookdown::pdf_document2:
    highlight: tango  # pygments
    toc: FALSE
    number_sections: FALSE
    df_print: tibble
    latex_engine: pdflatex
    keep_tex: FALSE
urlcolor: blue
---

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, warning = FALSE, message = FALSE, fig.align = "center",
  out.width = "100%", dpi = 300, fig.asp = 0.618, collapse = TRUE
)
```

```{r libraries}
# temporary and not recommended way, library(postforecasts) imports only functions with @export tag
# => requires more complete documentation
devtools::load_all(".")

library(scoringutils)
library(dplyr)
```

# Original Dataframe

We use the updated Dataframe.

```{r}
df <- read.csv(here::here("data", "full-data-european-forecast-hub-1.csv"))
```

# Plot Original Predictions

```{r}
model <- "epiforecasts-EpiExpert"
plot_quantiles(df, model, quantiles = c(0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99))
```

# Update Predictions

We update the prediction values over a set of different train and validation sets and store the results in a new dataframe for later analysis.

```{r}
# unique(df$model)
df_save <- cross_validation(
  df = df, models = c("epiforecasts-EpiExpert"),
  method = "cqr", training_lengths = c(40)
) # seq(40,73,1)

# TODO: in .rds speichern, mit datentyp. tidyverse ads reader.
# write.csv(df_save,here::here("data", "full-data-european-forecast-hub-2-updated-epiforecasts-EpiExpert.csv"), row.names = FALSE)

unique(df_save$target_end_date)
sum(is.na(df_save$target_end_date))
```
 
```{r}
# unique(df$model)
df_forecast <- update_predictions(df=df, 
                                  method="cqr",
                                  models="epiforecasts-EpiExpert",
                                  locations = "GB",
                                  cv_init_training=4) #seq(40,73,1)


pred_new <- df_forecast$prediction 

pred_old <- df |> 
  filter_models(c("epiforecasts-EpiExpert")) |> 
  filter_locations(c("GB")) |> dplyr::pull(prediction)

print(sum(abs(pred_old - pred_new)))

pred_old - pred_new # zeros could be the extremest quantiles that are not adjusted?

old <- dplyr::filter(df, location == "GB" & model == "epiforecasts-EpiExpert" & target_type == "Cases" & horizon == 1 & quantile == 1 - 0.05) |> dplyr::arrange(target_end_date) |> dplyr::pull(prediction)

new <- dplyr::filter(df_forecast, location == "GB" & model == "epiforecasts-EpiExpert" & target_type == "Cases" & horizon == 1 & quantile == 1 - 0.05) |> dplyr::arrange(target_end_date) |> dplyr::pull(prediction)

old - new

#TODO: in .ads speichern, mit datentyp. tidyverse ads reader.
#write.csv(df_save,here::here("data", "full-data-european-forecast-hub-2-updated-epiforecasts-EpiExpert.csv"), row.names = FALSE)

unique(df$model)
#sum(is.na(df_save$target_end_date))
```
 
 
# Numerical Analysis

```{r}
# TODO: Score table for the train and validation set are reported. We want to separate them
scores_combined <- df_save |>
  filter(model == !!model) |>
  eval_forecasts(summarise_by = c("method", "model", "target_type"))

scores_combined |>
  arrange(target_type, desc(method))
```

class(unique(df_save$target_end_date))

# Graphical Analysis

## for given `model`, `target_type`, `horizon` and `quantile`

#Plot 1: a score (over the full dataset) depending on the training set length

```{r}
score <- "Interval Score"

scores_table <- scores_combined |>
  arrange(target_type, desc(method))

interval_scores <- scores_table$interval_score[0:35]
training <- c(0, seq(73, 40, -1))

ggplot2::ggplot() +
  ggplot2::geom_point(ggplot2::aes(x = training, y = interval_scores)) +
  ggplot2::labs(
    title = stringr::str_glue("{score} for different training set sizes {model} model"),
    # subtitle = "True Values indicated by black line",
    color = NULL, x = "Training Set Size", y = "{score}",
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(nrow = 1)) +
  ggplot2::theme_light() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5),
    legend.position = "top"
  )
```

```{r}
# interface will change soon
plot_quantiles(df_save, model = model, quantiles = c(0.05, 0.5, 0.95))
```


```{r}
# interface will change soon
plot_cqr_results(df, model, target_type = "Cases", horizon = 1, quantile = 0.05)
```

## for given `model` and `quantile` and different `horizons`

```{r}
plot_intervals_grid(df_combined, model, facet_by = "horizon")
```

## for given `model` and `horizon` and different `quantiles`

```{r}
plot_intervals_grid(df_combined, model, facet_by = "quantile")
```
